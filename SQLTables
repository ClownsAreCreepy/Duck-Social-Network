-- Table: public.Users

-- DROP TABLE IF EXISTS public."Users";

CREATE TABLE IF NOT EXISTS public."Users"
(
    "idUser" bigint NOT NULL,
    username citext COLLATE pg_catalog."default" NOT NULL,
    email citext COLLATE pg_catalog."default" NOT NULL,
    password character varying(200) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT "User_pkey" PRIMARY KEY ("idUser")
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public."Users"
    OWNER to postgres;
-- Index: ux_users_email

-- DROP INDEX IF EXISTS public.ux_users_email;

CREATE UNIQUE INDEX IF NOT EXISTS ux_users_email
    ON public."Users" USING btree
    (email COLLATE pg_catalog."default" ASC NULLS LAST)
    WITH (fillfactor=100, deduplicate_items=True)
    TABLESPACE pg_default;
-- Index: ux_users_username

-- DROP INDEX IF EXISTS public.ux_users_username;

CREATE UNIQUE INDEX IF NOT EXISTS ux_users_username
    ON public."Users" USING btree
    (username COLLATE pg_catalog."default" ASC NULLS LAST)
    WITH (fillfactor=100, deduplicate_items=True)
    TABLESPACE pg_default;
-- Table: public.Ducks

-- DROP TABLE IF EXISTS public."Ducks";

CREATE TABLE IF NOT EXISTS public."Ducks"
(
    "idDuck" bigint NOT NULL,
    speed double precision,
    resistance double precision,
    duck_type character varying(50) COLLATE pg_catalog."default",
    CONSTRAINT "Ducks_pkey" PRIMARY KEY ("idDuck"),
    CONSTRAINT fk_userduck FOREIGN KEY ("idDuck")
        REFERENCES public."Users" ("idUser") MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE,
    CONSTRAINT ck_duck_kind CHECK (duck_type::text = ANY (ARRAY['SWIMMING'::character varying::text, 'FLYING'::character varying::text, 'HYBRID'::character varying::text]))
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public."Ducks"
    OWNER to postgres;

-- Table: public.EventSubscribers

-- DROP TABLE IF EXISTS public."EventSubscribers";

CREATE TABLE IF NOT EXISTS public."EventSubscribers"
(
    id_event bigint NOT NULL,
    id_user bigint NOT NULL,
    CONSTRAINT "EventSubscribers_pkey" PRIMARY KEY (id_event, id_user),
    CONSTRAINT "EventSubscribers_id_event_fkey" FOREIGN KEY (id_event)
        REFERENCES public."Events" ("idEvent") MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE,
    CONSTRAINT "EventSubscribers_id_user_fkey" FOREIGN KEY (id_user)
        REFERENCES public."Users" ("idUser") MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public."EventSubscribers"
    OWNER to postgres;

-- Table: public.Events

-- DROP TABLE IF EXISTS public."Events";

CREATE TABLE IF NOT EXISTS public."Events"
(
    "idEvent" bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    name character varying(200) COLLATE pg_catalog."default" NOT NULL,
    last_notification text COLLATE pg_catalog."default",
    CONSTRAINT "Events_pkey" PRIMARY KEY ("idEvent")
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public."Events"
    OWNER to postgres;

-- Table: public.FriendRequests

-- DROP TABLE IF EXISTS public."FriendRequests";

CREATE TABLE IF NOT EXISTS public."FriendRequests"
(
    id_request bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    from_user_id bigint NOT NULL,
    to_user_id bigint NOT NULL,
    status request_status NOT NULL DEFAULT 'PENDING'::request_status,
    date timestamp without time zone NOT NULL DEFAULT now(),
    CONSTRAINT "FriendRequests_pkey" PRIMARY KEY (id_request),
    CONSTRAINT unique_request_pair UNIQUE (from_user_id, to_user_id),
    CONSTRAINT fk_fr_from_user FOREIGN KEY (from_user_id)
        REFERENCES public."Users" ("idUser") MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE,
    CONSTRAINT fk_fr_to_user FOREIGN KEY (to_user_id)
        REFERENCES public."Users" ("idUser") MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public."FriendRequests"
    OWNER to postgres;
-- Index: idx_fr_reciever_status

-- DROP INDEX IF EXISTS public.idx_fr_reciever_status;

CREATE INDEX IF NOT EXISTS idx_fr_reciever_status
    ON public."FriendRequests" USING btree
    (to_user_id ASC NULLS LAST, status ASC NULLS LAST)
    WITH (fillfactor=100, deduplicate_items=True)
    TABLESPACE pg_default;

-- Table: public.Friendships

-- DROP TABLE IF EXISTS public."Friendships";

CREATE TABLE IF NOT EXISTS public."Friendships"
(
    "idFriendship" bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    id_1 bigint NOT NULL,
    id_2 bigint NOT NULL,
    CONSTRAINT "Friendships_pkey" PRIMARY KEY ("idFriendship"),
    CONSTRAINT fk_userfriendship FOREIGN KEY (id_1)
        REFERENCES public."Users" ("idUser") MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE,
    CONSTRAINT fk_userotherfriendship FOREIGN KEY (id_2)
        REFERENCES public."Users" ("idUser") MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE,
    CONSTRAINT ck_friend_no_self CHECK (id_1 <> id_2)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public."Friendships"
    OWNER to postgres;
-- Index: idx_friendships_id1

-- DROP INDEX IF EXISTS public.idx_friendships_id1;

CREATE INDEX IF NOT EXISTS idx_friendships_id1
    ON public."Friendships" USING btree
    (id_1 ASC NULLS LAST)
    WITH (fillfactor=100, deduplicate_items=True)
    TABLESPACE pg_default;
-- Index: idx_friendships_id2

-- DROP INDEX IF EXISTS public.idx_friendships_id2;

CREATE INDEX IF NOT EXISTS idx_friendships_id2
    ON public."Friendships" USING btree
    (id_2 ASC NULLS LAST)
    WITH (fillfactor=100, deduplicate_items=True)
    TABLESPACE pg_default;
-- Index: ux_friendships_pair

-- DROP INDEX IF EXISTS public.ux_friendships_pair;

CREATE UNIQUE INDEX IF NOT EXISTS ux_friendships_pair
    ON public."Friendships" USING btree
    (LEAST(id_1, id_2) ASC NULLS LAST, GREATEST(id_1, id_2) ASC NULLS LAST)
    WITH (fillfactor=100, deduplicate_items=True)
    TABLESPACE pg_default;

-- Table: public.HerdMembers

-- DROP TABLE IF EXISTS public."HerdMembers";

CREATE TABLE IF NOT EXISTS public."HerdMembers"
(
    id_herd bigint NOT NULL,
    id_duck bigint NOT NULL,
    CONSTRAINT "HerdMembers_pkey" PRIMARY KEY (id_herd, id_duck),
    CONSTRAINT "HerdMembers_id_duck_fkey" FOREIGN KEY (id_duck)
        REFERENCES public."Ducks" ("idDuck") MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE,
    CONSTRAINT "HerdMembers_id_herd_fkey" FOREIGN KEY (id_herd)
        REFERENCES public."Herds" ("idHerd") MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public."HerdMembers"
    OWNER to postgres;

-- Table: public.Herds

-- DROP TABLE IF EXISTS public."Herds";

CREATE TABLE IF NOT EXISTS public."Herds"
(
    "idHerd" bigint NOT NULL GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    "herdName" character varying(100) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT "Herds_pkey" PRIMARY KEY ("idHerd")
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public."Herds"
    OWNER to postgres;

-- Table: public.MessageRecipients

-- DROP TABLE IF EXISTS public."MessageRecipients";

CREATE TABLE IF NOT EXISTS public."MessageRecipients"
(
    id_message bigint NOT NULL,
    id_recipient bigint NOT NULL,
    CONSTRAINT pk_message_recipients PRIMARY KEY (id_message, id_recipient),
    CONSTRAINT fk_mr_message FOREIGN KEY (id_message)
        REFERENCES public."Messages" (id_message) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE,
    CONSTRAINT fk_mr_user FOREIGN KEY (id_recipient)
        REFERENCES public."Users" ("idUser") MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public."MessageRecipients"
    OWNER to postgres;
-- Index: idx_recipient_lookup

-- DROP INDEX IF EXISTS public.idx_recipient_lookup;

CREATE INDEX IF NOT EXISTS idx_recipient_lookup
    ON public."MessageRecipients" USING btree
    (id_recipient ASC NULLS LAST, id_message ASC NULLS LAST)
    WITH (fillfactor=100, deduplicate_items=True)
    TABLESPACE pg_default;

-- Table: public.Messages

-- DROP TABLE IF EXISTS public."Messages";

CREATE TABLE IF NOT EXISTS public."Messages"
(
    id_message bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    from_user_id bigint NOT NULL,
    message_text text COLLATE pg_catalog."default" NOT NULL,
    send_at timestamp without time zone NOT NULL DEFAULT now(),
    reply_to bigint,
    CONSTRAINT pk_messages PRIMARY KEY (id_message),
    CONSTRAINT fk_message_reply FOREIGN KEY (reply_to)
        REFERENCES public."Messages" (id_message) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE SET NULL,
    CONSTRAINT fk_user_message FOREIGN KEY (from_user_id)
        REFERENCES public."Users" ("idUser") MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public."Messages"
    OWNER to postgres;
-- Index: idx_sender_lookup

-- DROP INDEX IF EXISTS public.idx_sender_lookup;

CREATE INDEX IF NOT EXISTS idx_sender_lookup
    ON public."Messages" USING btree
    (from_user_id ASC NULLS LAST)
    WITH (fillfactor=100, deduplicate_items=True)
    TABLESPACE pg_default;

-- Table: public.People

-- DROP TABLE IF EXISTS public."People";

CREATE TABLE IF NOT EXISTS public."People"
(
    "idPerson" bigint NOT NULL,
    name character varying(200) COLLATE pg_catalog."default",
    firstname character varying(200) COLLATE pg_catalog."default",
    "birthDate" date,
    occupation character varying(200) COLLATE pg_catalog."default",
    CONSTRAINT "Person_pkey" PRIMARY KEY ("idPerson"),
    CONSTRAINT fk_userperson FOREIGN KEY ("idPerson")
        REFERENCES public."Users" ("idUser") MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public."People"
    OWNER to postgres;